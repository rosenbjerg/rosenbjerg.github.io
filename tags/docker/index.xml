<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>docker on Rosenbjerg blog</title><link>https://rosenbjerg.dk/tags/docker/</link><description>Recent content in docker on Rosenbjerg blog</description><generator>Hugo -- gohugo.io</generator><language>en-UK</language><lastBuildDate>Sun, 11 Jun 2023 22:27:28 +0100</lastBuildDate><atom:link href="https://rosenbjerg.dk/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Containerized .NET build cache optimizations</title><link>https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/</link><pubDate>Sun, 11 Jun 2023 22:27:28 +0100</pubDate><guid>https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/</guid><description>Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker&amp;rsquo;s build cache. If Docker recognizes that a layer hasn&amp;rsquo;t changed (i.e., the command is the same and the context hasn&amp;rsquo;t changed), it reuses the existing layer instead of rebuilding it.
When building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built.</description></item><item><title>No curl, No wget, No Problem - A Bash Script for Container Healthchecks</title><link>https://rosenbjerg.dk/posts/slim-mans-container-healthcheck-client/</link><pubDate>Fri, 19 May 2023 19:09:58 +0100</pubDate><guid>https://rosenbjerg.dk/posts/slim-mans-container-healthcheck-client/</guid><description>Alright, let&amp;rsquo;s get straight to the point: building reliable software is critical. It&amp;rsquo;s not just a matter of nice-to-haves; it&amp;rsquo;s about building something that stands the test of time and isn&amp;rsquo;t prone to constant crashes. Now, this requires us to keep a diligent watch on the software&amp;rsquo;s health. And when it comes to systems based on microservices, where there are numerous components working in tandem, this becomes even more important. Enter health checks.</description></item><item><title>No installs - just containers</title><link>https://rosenbjerg.dk/posts/no-installs-just-containers/</link><pubDate>Wed, 30 Nov 2022 22:17:58 +0100</pubDate><guid>https://rosenbjerg.dk/posts/no-installs-just-containers/</guid><description>It can be annoying to install a tool that is only needed a few times, and it would be preferable to avoid the installation process. However, sometimes it is necessary to use a tool to accomplish a specific task
Solution To avoid the inconvenience of installing tools that are only needed occasionally, I have started using containerized tools instead. To make it easier to use these containerized tools, I have created a number of .</description></item><item><title>WSL2 + podman</title><link>https://rosenbjerg.dk/posts/podman-docker-desktop-alternative/</link><pubDate>Mon, 24 Jan 2022 08:34:05 +0100</pubDate><guid>https://rosenbjerg.dk/posts/podman-docker-desktop-alternative/</guid><description>UPDATE: podman desktop is now a thing!
I had been having some issues with the docker-desktop service on Windows, where it wouldn&amp;rsquo;t autostart properly and would start into a broken state where nothing worked. These problems, together with the license change of the docker-desktop product and recommendations to give podman a try, led me to try podman instead.
About podman podman is a container runtime like docker but designed with a different philosophy.</description></item></channel></rss>