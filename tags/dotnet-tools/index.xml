<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>dotnet-tools on Rosenbjerg blog</title><link>https://rosenbjerg.dk/tags/dotnet-tools/</link><description>Recent content in dotnet-tools on Rosenbjerg blog</description><generator>Hugo -- gohugo.io</generator><language>en-UK</language><lastBuildDate>Sun, 11 Jun 2023 22:27:28 +0100</lastBuildDate><atom:link href="https://rosenbjerg.dk/tags/dotnet-tools/index.xml" rel="self" type="application/rss+xml"/><item><title>Containerized .NET build cache optimizations</title><link>https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/</link><pubDate>Sun, 11 Jun 2023 22:27:28 +0100</pubDate><guid>https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/</guid><description>Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker&amp;rsquo;s build cache. If Docker recognizes that a layer hasn&amp;rsquo;t changed (i.e., the command is the same and the context hasn&amp;rsquo;t changed), it reuses the existing layer instead of rebuilding it.
When building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built.</description></item></channel></rss>