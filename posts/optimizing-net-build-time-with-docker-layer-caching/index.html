<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Containerized .NET build cache optimizations | Rosenbjerg blog</title><meta name=keywords content="docker,net,containers,build-cache,dotnet-tools"><meta name=description content="Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker&rsquo;s build cache. If Docker recognizes that a layer hasn&rsquo;t changed (i.e., the command is the same and the context hasn&rsquo;t changed), it reuses the existing layer instead of rebuilding it.
When building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built."><meta name=author content><link rel=canonical href=https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rosenbjerg.dk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rosenbjerg.dk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rosenbjerg.dk/favicon-32x32.png><link rel=apple-touch-icon href=https://rosenbjerg.dk/apple-touch-icon.png><link rel=mask-icon href=https://rosenbjerg.dk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.113.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Containerized .NET build cache optimizations"><meta property="og:description" content="Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker&rsquo;s build cache. If Docker recognizes that a layer hasn&rsquo;t changed (i.e., the command is the same and the context hasn&rsquo;t changed), it reuses the existing layer instead of rebuilding it.
When building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built."><meta property="og:type" content="article"><meta property="og:url" content="https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-11T22:27:28+01:00"><meta property="article:modified_time" content="2023-06-11T22:27:28+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Containerized .NET build cache optimizations"><meta name=twitter:description content="Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker&rsquo;s build cache. If Docker recognizes that a layer hasn&rsquo;t changed (i.e., the command is the same and the context hasn&rsquo;t changed), it reuses the existing layer instead of rebuilding it.
When building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rosenbjerg.dk/posts/"},{"@type":"ListItem","position":2,"name":"Containerized .NET build cache optimizations","item":"https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Containerized .NET build cache optimizations","name":"Containerized .NET build cache optimizations","description":"Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker\u0026rsquo;s build cache. If Docker recognizes that a layer hasn\u0026rsquo;t changed (i.e., the command is the same and the context hasn\u0026rsquo;t changed), it reuses the existing layer instead of rebuilding it.\nWhen building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built.","keywords":["docker","net","containers","build-cache","dotnet-tools"],"articleBody":"Docker Build Cache Reuse Docker utilizes a layering system for its images. Each command in a Dockerfile creates a new layer that is built upon the previous one. This layering system is leveraged by Docker’s build cache. If Docker recognizes that a layer hasn’t changed (i.e., the command is the same and the context hasn’t changed), it reuses the existing layer instead of rebuilding it.\nWhen building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built. This is done because restoring dependencies can be a time-consuming process, and it’s often the case that dependencies change less frequently than the application code. By restoring dependencies as a separate step, Docker can reuse the cached layer for the restore step, significantly speeding up the build process.\nThe recreate-sln-structure tool aids in this process by moving project files into the directories specified by the solution (.sln) file. This allows Docker to better track changes to individual projects and reuse cached layers when a project hasn’t changed, leading to more efficient builds.\nThe Need for recreate-sln-structure When working with Docker, the COPY command is often used to copy files from the host into the Docker image. However, when using wildcards to copy multiple files, Docker flattens the directory structure. This means that all files, regardless of their original directory, are copied into the same destination directory.\nThis can be problematic when working with .NET solutions, as the structure of the solution can be important. For example, project references are often based on the relative paths of the projects within the solution.\nThis is where recreate-sln-structure comes in. After copying the project files into the Docker image, recreate-sln-structure can be used to move the project files into the directories specified by the solution (.sln) file, effectively recreating the original solution structure within the Docker image.\nWorking with Solution Filter (.slnf) Files Solution Filter (.slnf) files are a feature in Visual Studio that allows developers to open a subset of a larger solution. This is particularly useful in large codebases where loading the entire solution can be time-consuming and resource-intensive.\nThe slnf-gen tool generates these .slnf files based on globs. For example, you could exclude all test projects, or only include projects in a specific directory. When you open the .slnf file in Visual Studio, only the included projects are loaded. This can significantly speed up solution load times and reduce the amount of memory used by Visual Studio, making it easier to work on large solutions.\nIn addition, .slnf files can also be used with the dotnet CLI. For example, you can restore or build only the projects included in the .slnf file. This can be useful in CI/CD pipelines where you might want to build or test a subset of a larger solution.\nUsing slnf-gen and recreate-sln-structure in Tandem slnf-gen and recreate-sln-structure can be used together to create an extremely lean containerized .NET build process.\nIn this Dockerfile, we first copy the solution and project files into the Docker image. We then use recreate-sln-structure to restore the original solution structure within the Docker image.\nNext, we use slnf-gen to generate a .slnf file that includes only the necessary projects for the build, excluding any test projects. We then restore these projects using dotnet restore.\nAfter the necessary projects have been restored, we copy the rest of the application files into the Docker image. Finally, we build the necessary projects using dotnet build.\nThis process results in a Docker image that includes only what’s necessary for the application to run, making the image as lean and efficient as possible.\nHere’s an example of what this might look like in a Dockerfile:\nFROM bitnami/dotnet-sdk:6 # Copy solution and project files into Docker image COPY [\"MySolution.sln\", \"**/*.csproj\", \"./\"] # Recreate solution structure, generate .slnf file, and restore. # This step's cache is only invalidated when .sln or .csproj files are modified (or added) RUN recreate-sln-structure MySolution.sln \u0026\u0026 \\ slnf-gen MySolution.sln --exclude **/*Test* \u0026\u0026 \\ dotnet restore MySolution.slnf # Copy the rest of the source files COPY [\"./\", \"./\"] # Build the necessary projects. This steps cache is reused across usages with different values for PUBLISH_PROJECT RUN dotnet build MySolution.slnf --no-restore # Argument for the project to be published ARG PUBLISH_PROJECT=MyProject # Publish the specified project without building it again RUN dotnet publish \"${PUBLISH_PROJECT}/${PUBLISH_PROJECT}.csproj\" --no-build --output /app/ ... FROM ... In this Dockerfile, we first copy the solution and project files into the Docker image. We then use recreate-sln-structure to restore the original solution structure within the Docker image. This is necessary because Docker flattens the directory structure when copying multiple files.\nNext, we use slnf-gen to generate a .slnf file that includes only the necessary projects for the build, excluding any test projects. We then restore these projects using dotnet restore. This step’s cache is only invalidated when .sln or .csproj files are modified or added, which means Docker can reuse the cached layer for the restore step in most builds, significantly speeding up the build process.\nAfter the necessary projects have been restored, we copy the rest of the source files into the Docker image. We then build the necessary projects using dotnet build with the –no-restore option, which ensures that we don’t restore the projects again.\nFinally, we use an argument to specify the project to be published. We then publish this project using dotnet publish with the –no-build option, which ensures that we don’t build the project again. The published files are output to the /app/ directory in the Docker image.\nThis makes the build process as lean and efficient as possible since we only build exactly what is necessary, when it is necessary.\nIn conclusion, slnf-gen and recreate-sln-structure are powerful tools that can help streamline your .NET development workflow. Whether used individually or in tandem, they offer practical solutions to common challenges in .NET project management and Docker containerization.\n","wordCount":"987","inLanguage":"en","datePublished":"2023-06-11T22:27:28+01:00","dateModified":"2023-06-11T22:27:28+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rosenbjerg.dk/posts/optimizing-net-build-time-with-docker-layer-caching/"},"publisher":{"@type":"Organization","name":"Rosenbjerg blog","logo":{"@type":"ImageObject","url":"https://rosenbjerg.dk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rosenbjerg.dk/ accesskey=h title="Rosenbjerg blog (Alt + H)">Rosenbjerg blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Containerized .NET build cache optimizations</h1><div class=post-meta><span title='2023-06-11 22:27:28 +0100 +0100'>June 11, 2023</span></div></header><div class=post-content><h1 id=docker-build-cache-reuse>Docker Build Cache Reuse<a hidden class=anchor aria-hidden=true href=#docker-build-cache-reuse>#</a></h1><p>Docker utilizes a layering system for its images.
Each command in a Dockerfile creates a new layer that is built upon the previous one.
This layering system is leveraged by Docker&rsquo;s build cache.
If Docker recognizes that a layer hasn&rsquo;t changed (i.e., the command is the same and the context hasn&rsquo;t changed), it reuses the existing layer instead of rebuilding it.</p><p>When building .NET applications in Docker, one common practice is to restore dependencies as a separate step before the application is built.
This is done because restoring dependencies can be a time-consuming process, and it&rsquo;s often the case that dependencies change less frequently than the application code.
By restoring dependencies as a separate step, Docker can reuse the cached layer for the restore step, significantly speeding up the build process.</p><p>The <a href=https://github.com/rosenbjerg/recreate-sln-structure target=_blank><code>recreate-sln-structure</code></a>
tool aids in this process by moving project files into the directories specified by the solution (.sln) file.
This allows Docker to better track changes to individual projects and reuse cached layers when a project hasn&rsquo;t changed, leading to more efficient builds.</p><h2 id=the-need-for-recreate-sln-structure>The Need for recreate-sln-structure<a hidden class=anchor aria-hidden=true href=#the-need-for-recreate-sln-structure>#</a></h2><p>When working with Docker, the <code>COPY</code> command is often used to copy files from the host into the Docker image.
However, when using wildcards to copy multiple files, Docker flattens the directory structure.
This means that all files, regardless of their original directory, are copied into the same destination directory.</p><p>This can be problematic when working with .NET solutions, as the structure of the solution can be important.
For example, project references are often based on the relative paths of the projects within the solution.</p><p>This is where <code>recreate-sln-structure</code> comes in.
After copying the project files into the Docker image, <code>recreate-sln-structure</code> can be used to move the project files into the directories specified by the solution (.sln) file, effectively recreating the original solution structure within the Docker image.</p><h1 id=working-with-solution-filter-slnf-files>Working with Solution Filter (.slnf) Files<a hidden class=anchor aria-hidden=true href=#working-with-solution-filter-slnf-files>#</a></h1><p>Solution Filter (.slnf) files are a feature in Visual Studio that allows developers to open a subset of a larger solution.
This is particularly useful in large codebases where loading the entire solution can be time-consuming and resource-intensive.</p><p>The <a href=https://github.com/rosenbjerg/slnf-gen target=_blank><code>slnf-gen</code></a>
tool generates these <code>.slnf</code> files based on globs. For example, you could exclude all test projects, or only include projects in a specific directory.
When you open the <code>.slnf</code> file in Visual Studio, only the included projects are loaded. This can significantly speed up solution load times and reduce the amount of memory used by Visual Studio, making it easier to work on large solutions.</p><p>In addition, <code>.slnf</code> files can also be used with the dotnet CLI. For example, you can restore or build only the projects included in the <code>.slnf</code> file.
This can be useful in CI/CD pipelines where you might want to build or test a subset of a larger solution.</p><h1 id=using-slnf-gen-and-recreate-sln-structure-in-tandem>Using <code>slnf-gen</code> and recreate-sln-structure in Tandem<a hidden class=anchor aria-hidden=true href=#using-slnf-gen-and-recreate-sln-structure-in-tandem>#</a></h1><p><code>slnf-gen</code> and <code>recreate-sln-structure</code> can be used together to create an extremely lean containerized .NET build process.</p><p>In this Dockerfile, we first copy the solution and project files into the Docker image.
We then use recreate-sln-structure to restore the original solution structure within the Docker image.</p><p>Next, we use <code>slnf-gen</code> to generate a <code>.slnf</code> file that includes only the necessary projects for the build, excluding any test projects.
We then restore these projects using dotnet restore.</p><p>After the necessary projects have been restored, we copy the rest of the application files into the Docker image.
Finally, we build the necessary projects using dotnet build.</p><p>This process results in a Docker image that includes only what&rsquo;s necessary for the application to run, making the image as lean and efficient as possible.</p><p>Here&rsquo;s an example of what this might look like in a Dockerfile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> bitnami/dotnet-sdk:6</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy solution and project files into Docker image</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;MySolution.sln&#34;</span>, <span style=color:#e6db74>&#34;**/*.csproj&#34;</span>, <span style=color:#e6db74>&#34;./&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Recreate solution structure, generate .slnf file, and restore. </span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># This step&#39;s cache is only invalidated when .sln or .csproj files are modified (or added)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> recreate-sln-structure MySolution.sln <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    slnf-gen MySolution.sln --exclude **/*Test* <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    dotnet restore MySolution.slnf<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy the rest of the source files</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;./&#34;</span>, <span style=color:#e6db74>&#34;./&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Build the necessary projects. This steps cache is reused across usages with different values for PUBLISH_PROJECT</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet build MySolution.slnf --no-restore<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Argument for the project to be published</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> PUBLISH_PROJECT<span style=color:#f92672>=</span>MyProject
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Publish the specified project without building it again</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet publish <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>PUBLISH_PROJECT<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>PUBLISH_PROJECT<span style=color:#e6db74>}</span><span style=color:#e6db74>.csproj&#34;</span> --no-build --output /app/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>...<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ...</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>In this Dockerfile, we first copy the solution and project files into the Docker image.
We then use recreate-sln-structure to restore the original solution structure within the Docker image.
This is necessary because Docker flattens the directory structure when copying multiple files.</p><p>Next, we use slnf-gen to generate a .slnf file that includes only the necessary projects for the build, excluding any test projects.
We then restore these projects using dotnet restore.
This step&rsquo;s cache is only invalidated when .sln or .csproj files are modified or added, which means Docker can reuse the cached layer for the restore step in most builds, significantly speeding up the build process.</p><p>After the necessary projects have been restored, we copy the rest of the source files into the Docker image.
We then build the necessary projects using dotnet build with the &ndash;no-restore option, which ensures that we don&rsquo;t restore the projects again.</p><p>Finally, we use an argument to specify the project to be published.
We then publish this project using dotnet publish with the &ndash;no-build option, which ensures that we don&rsquo;t build the project again.
The published files are output to the /app/ directory in the Docker image.</p><p>This makes the build process as lean and efficient as possible since we only build exactly what is necessary, when it is necessary.</p><p>In conclusion, <a href=https://github.com/rosenbjerg/slnf-gen target=_blank><code>slnf-gen</code></a>
and <a href=https://github.com/rosenbjerg/recreate-sln-structure target=_blank><code>recreate-sln-structure</code></a>
are powerful tools that can help streamline your .NET development workflow.
Whether used individually or in tandem, they offer practical solutions to common challenges in .NET project management and Docker containerization.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rosenbjerg.dk/tags/docker/>docker</a></li><li><a href=https://rosenbjerg.dk/tags/net/>net</a></li><li><a href=https://rosenbjerg.dk/tags/containers/>containers</a></li><li><a href=https://rosenbjerg.dk/tags/build-cache/>build-cache</a></li><li><a href=https://rosenbjerg.dk/tags/dotnet-tools/>dotnet-tools</a></li></ul></footer><script src=https://utteranc.es/client.js repo=rosenbjerg/rosenbjerg.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://rosenbjerg.dk/>Rosenbjerg blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>